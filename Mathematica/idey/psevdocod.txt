Нужно както указывать функциям что вместо uf нужно использовать либо реальную, либо мнимую части, либо абсолютное значение. можно задать матрицу muf состоящую из (1-реальная часть, 2-мнимая часть, 3-модуль). получится muf[1][x][2], будет реальной частью функции psi2 от x

// Функция поиска масива границ в которых ноль//
funk_null(x1, x2, n, psi){        \\psi=какой из элементов psi проверяем 1,2,3\\     
	null[0]=-1
	dx=abs(x2-x1)/n
	x=x1
	for (i=0, x<=x2){
		xx[i]=x
		ff[i]=uf[psi][x]
		if (ff[i]<0) {m[i]=-1}
		if (ff[i]>0) {m[i]=1}
		x=x+dx
		i++
	}
	for (i=0 k=0, i<n){
		if (m[i]+m[i+1]=0) {
			null[k]=xx[i]
			null[k+1]=xx[i+1]
			k=k+2
		}
		i++
	}
	return(null[])
}

//Точное определение координат нуля//
func_tochn_null (x1, x2, n, dx, psi){
	for(abs(x1-x2)<=dx){
		if (length(funk_null(x1, (x2+x1)/2, n, psi))=2){
			x2=(x2+x1)/2
		} else{x1=(x2+x1)/2}
	}
	return(x1)
}

// Определение границ в которых три ближайших к x0 нуля//
funk_granic(x0, x1, x2, n, psi){      \\psi=какой из элементов psi проверяем 1,2,3\\
	n01=-1
	n02=-2
	for (i=0, i<6 или n01=n02){
		n=n*(4+i)^i            \\ Так странно потомучто, если uf(x1) близко к uf(x2) и между ними 1000 нулей, то при n=10, а потом n=n*10=100 нули не будут найдены, и цикл будет завершен. поэтому желательно каждый раз n умножать на разные числа//
		null=funk_null(x1, x2, n, psi)
		n01=n02
		n02=length(null)/2
	}
	f0=uf(x0)
	k=abs(f0-null[1])
	l=-1
	for (i=2, i<=2*n02){
		h=abs(f0-null[i])
		if (h<k) {
			k=h
			l=i
		}
		i=i+2
	}
	x1=func_tochn_null(xx[l-2], xx[l-1], n, dx, psi)
	x1=func_tochn_null(xx[l+3], xx[l+2], n, dx, psi)
	return(x1 and x2 and n)
}

x01 and x02 and n = funk_granic(x0, x1, x2, n, psi)
количество нулей в границах x01; x02 для psi_i = funk_null(x01, x02, n, psi=i)